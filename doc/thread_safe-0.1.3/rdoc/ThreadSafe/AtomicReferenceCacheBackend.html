<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type" />

  <title>Class: ThreadSafe::AtomicReferenceCacheBackend</title>

  <link rel="stylesheet" href="../rdoc.css" type="text/css" media="screen" />

  <script src="../js/jquery.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/thickbox-compressed.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/quicksearch.js" type="text/javascript" charset="utf-8"></script>
  <script src="../js/darkfish.js" type="text/javascript" charset="utf-8"></script>

</head>
<body id="top" class="class">

  <div id="metadata">
    <div id="home-metadata">
      <div id="home-section" class="section">
        <h3 class="section-header">
          <a href="../index.html">Home</a>
          <a href="../index.html#classes">Classes</a>
          <a href="../index.html#methods">Methods</a>
        </h3>
      </div>
    </div>

    <div id="file-metadata">
      <div id="file-list-section" class="section">
        <h3 class="section-header">In Files</h3>
        <div class="section-body">
          <ul>
          
            <li><a href="../lib/thread_safe/atomic_reference_cache_backend_rb.html?TB_iframe=true&amp;height=550&amp;width=785"
              class="thickbox" title="lib/thread_safe/atomic_reference_cache_backend.rb">lib/thread_safe/atomic_reference_cache_backend.rb</a></li>
          
          </ul>
        </div>
      </div>

      
    </div>

    <div id="class-metadata">
      
      <!-- Parent Class -->
      <div id="parent-class-section" class="section">
        <h3 class="section-header">Parent</h3>
        
        <p class="link">Object</p>
        
      </div>
      

      

      
      <!-- Namespace Contents -->
      <div id="namespace-list-section" class="section">
        <h3 class="section-header">Namespace</h3>
        <ul class="link-list">
          
          <li><span class="type">CLASS</span> <a href="AtomicReferenceCacheBackend/Node.html">ThreadSafe::AtomicReferenceCacheBackend::Node</a></li>
          
          <li><span class="type">CLASS</span> <a href="AtomicReferenceCacheBackend/Table.html">ThreadSafe::AtomicReferenceCacheBackend::Table</a></li>
          
        </ul>
      </div>
      

      
      <!-- Method Quickref -->
      <div id="method-list-section" class="section">
        <h3 class="section-header">Methods</h3>
        <ul class="link-list">
          
          <li><a href="#method-c-new">::new</a></li>
          
          <li><a href="#method-i-5B-5D">#[]</a></li>
          
          <li><a href="#method-i-5B-5D-3D">#[]=</a></li>
          
          <li><a href="#method-i-clear">#clear</a></li>
          
          <li><a href="#method-i-compute">#compute</a></li>
          
          <li><a href="#method-i-compute_if_absent">#compute_if_absent</a></li>
          
          <li><a href="#method-i-compute_if_present">#compute_if_present</a></li>
          
          <li><a href="#method-i-delete">#delete</a></li>
          
          <li><a href="#method-i-delete_pair">#delete_pair</a></li>
          
          <li><a href="#method-i-each_pair">#each_pair</a></li>
          
          <li><a href="#method-i-empty-3F">#empty?</a></li>
          
          <li><a href="#method-i-get_and_set">#get_and_set</a></li>
          
          <li><a href="#method-i-get_or_default">#get_or_default</a></li>
          
          <li><a href="#method-i-key-3F">#key?</a></li>
          
          <li><a href="#method-i-merge_pair">#merge_pair</a></li>
          
          <li><a href="#method-i-replace_if_exists">#replace_if_exists</a></li>
          
          <li><a href="#method-i-replace_pair">#replace_pair</a></li>
          
          <li><a href="#method-i-size">#size</a></li>
          
        </ul>
      </div>
      

      
    </div>

    <div id="project-metadata">
      
      

      <div id="classindex-section" class="section project-section">
        <h3 class="section-header">Class/Module Index
          <span class="search-toggle"><img src="../images/find.png"
            height="16" width="16" alt="[+]"
            title="show/hide quicksearch" /></span></h3>
        <form action="#" method="get" accept-charset="utf-8" class="initially-hidden">
        <fieldset>
          <legend>Quicksearch</legend>
          <input type="text" name="quicksearch" value=""
            class="quicksearch-field" />
        </fieldset>
        </form>

        <ul class="link-list">
        
          <li><a href="../ThreadSafe.html">ThreadSafe</a></li>
        
          <li><a href="../ThreadSafe/Array.html">ThreadSafe::Array</a></li>
        
          <li><a href="../ThreadSafe/AtomicReferenceCacheBackend.html">ThreadSafe::AtomicReferenceCacheBackend</a></li>
        
          <li><a href="../ThreadSafe/AtomicReferenceCacheBackend/Node.html">ThreadSafe::AtomicReferenceCacheBackend::Node</a></li>
        
          <li><a href="../ThreadSafe/AtomicReferenceCacheBackend/Table.html">ThreadSafe::AtomicReferenceCacheBackend::Table</a></li>
        
          <li><a href="../ThreadSafe/Cache.html">ThreadSafe::Cache</a></li>
        
          <li><a href="../ThreadSafe/Hash.html">ThreadSafe::Hash</a></li>
        
          <li><a href="../ThreadSafe/MriCacheBackend.html">ThreadSafe::MriCacheBackend</a></li>
        
          <li><a href="../ThreadSafe/NonConcurrentCacheBackend.html">ThreadSafe::NonConcurrentCacheBackend</a></li>
        
          <li><a href="../ThreadSafe/SynchronizedCacheBackend.html">ThreadSafe::SynchronizedCacheBackend</a></li>
        
          <li><a href="../ThreadSafe/Util.html">ThreadSafe::Util</a></li>
        
          <li><a href="../ThreadSafe/Util/Adder.html">ThreadSafe::Util::Adder</a></li>
        
          <li><a href="../ThreadSafe/Util/CheapLockable.html">ThreadSafe::Util::CheapLockable</a></li>
        
          <li><a href="../ThreadSafe/Util/PowerOfTwoTuple.html">ThreadSafe::Util::PowerOfTwoTuple</a></li>
        
          <li><a href="../ThreadSafe/Util/Striped64.html">ThreadSafe::Util::Striped64</a></li>
        
          <li><a href="../ThreadSafe/Util/Striped64/Cell.html">ThreadSafe::Util::Striped64::Cell</a></li>
        
          <li><a href="../ThreadSafe/Util/Volatile.html">ThreadSafe::Util::Volatile</a></li>
        
          <li><a href="../ThreadSafe/Util/VolatileTuple.html">ThreadSafe::Util::VolatileTuple</a></li>
        
          <li><a href="../ThreadSafe/Util/XorShiftRandom.html">ThreadSafe::Util::XorShiftRandom</a></li>
        
          <li><a href="../SynchronizedDelegator.html">SynchronizedDelegator</a></li>
        
          <li><a href="../Threadsafe.html">Threadsafe</a></li>
        
        </ul>
        <div id="no-class-search-results" style="display: none;">No matching classes.</div>
      </div>

      
    </div>
  </div>

  <div id="documentation">
    <h1 class="class">ThreadSafe::AtomicReferenceCacheBackend</h1>

    <div id="description" class="description">
      
<p>A Ruby port of the Doug Lea’s jsr166e.ConcurrentHashMapV8 class version
1.59 available in public domain. Original source code available here: <a
href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?revision=1.59">gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/jsr166e/ConcurrentHashMapV8.java?revision=1.59</a></p>

<p>The Ruby port skips out the <tt>TreeBin</tt> (red-black trees for use in
bins whose size exceeds a threshold).</p>

<p>A hash table supporting full concurrency of retrievals and high expected
concurrency for updates. However, even though all operations are
thread-safe, retrieval operations do <em>not</em> entail locking, and there
is <em>not</em> any support for locking the entire table in a way that
prevents all access.</p>

<p>Retrieval operations generally do not block, so may overlap with update
operations. Retrievals reflect the results of the most recently
<em>completed</em> update operations holding upon their onset. (More
formally, an update operation for a given key bears a
<em>happens-before</em> relation with any (non <tt>nil</tt>) retrieval for
that key reporting the updated value.)  For aggregate operations such as
+clear()+, concurrent retrievals may reflect insertion or removal of only
some entries.  Similarly, the <tt>each_pair</tt> iterator yields elements
reflecting the state of the hash table at some point at or since the start
of the <tt>each_pair</tt>. Bear in mind that the results of aggregate
status methods including +size()+ and <tt>empty?</tt>} are typically useful
only when a map is not undergoing concurrent updates in other threads.
Otherwise the results of these methods reflect transient states that may be
adequate for monitoring or estimation purposes, but not for program
control.</p>

<p>The table is dynamically expanded when there are too many collisions (i.e.,
keys that have distinct hash codes but fall into the same slot modulo the
table size), with the expected average effect of maintaining roughly two
bins per mapping (corresponding to a 0.75 load factor threshold for
resizing). There may be much variance around this average as mappings are
added and removed, but overall, this maintains a commonly accepted
time/space tradeoff for hash tables.  However, resizing this or any other
kind of hash table may be a relatively slow operation. When possible, it is
a good idea to provide a size estimate as an optional :initial_capacity
initializer argument. An additional optional :load_factor constructor
argument provides a further means of customizing initial table capacity by
specifying the table density to be used in calculating the amount of space
to allocate for the given number of elements. Note that using many keys
with exactly the same <tt>hash</tt> is a sure way to slow down performance
of any hash table.</p>

<h2>Design overview</h2>

<p>The primary design goal of this hash table is to maintain concurrent
readability (typically method +[]+, but also iteration and related methods)
while minimizing update contention. Secondary goals are to keep space
consumption about the same or better than plain <tt>Hash</tt>, and to
support high initial insertion rates on an empty table by many threads.</p>

<p>Each key-value mapping is held in a <tt>Node</tt>. The validation-based
approach explained below leads to a lot of code sprawl because
retry-control precludes factoring into smaller methods.</p>

<p>The table is lazily initialized to a power-of-two size upon the first
insertion.  Each bin in the table normally contains a list of +Node+s (most
often, the list has only zero or one <tt>Node</tt>). <a
href="AtomicReferenceCacheBackend/Table.html">Table</a> accesses require
volatile/atomic reads, writes, and CASes. The lists of nodes within bins
are always accurately traversable under volatile reads, so long as lookups
check hash code and non-nullness of value before checking key equality.</p>

<p>We use the top two bits of <tt>Node</tt> hash fields for control purposes –
they are available anyway because of addressing constraints.  As explained
further below, these top bits are used as follows:</p>

<pre>00 - Normal
01 - Locked
11 - Locked and may have a thread waiting for lock
10 - +Node+ is a forwarding node</pre>

<p>The lower 28 bits of each <tt>Node</tt>‘s hash field contain a the key’s
hash code, except for forwarding nodes, for which the lower bits are zero
(and so always have hash field == <tt>MOVED</tt>).</p>

<p>Insertion (via +[]=+ or its variants) of the first node in an empty bin is
performed by just CASing it to the bin.  This is by far the most common
case for put operations under most key/hash distributions.  Other update
operations (insert, delete, and replace) require locks.  We do not want to
waste the space required to associate a distinct lock object with each bin,
so instead use the first node of a bin list itself as a lock. Blocking
support for these locks relies +<a
href="Util/CheapLockable.html">Util::CheapLockable</a>. However, we also
need a <tt>try_lock</tt> construction, so we overlay these by using bits of
the <tt>Node</tt> hash field for lock control (see above), and so normally
use builtin monitors only for blocking and signalling using
<tt>cheap_wait</tt>/<tt>cheap_broadcast</tt> constructions. See +<a
href="AtomicReferenceCacheBackend/Node.html#method-i-try_await_lock">Node#try_await_lock</a>+.</p>

<p>Using the first node of a list as a lock does not by itself suffice though:
When a node is locked, any update must first validate that it is still the
first node after locking it, and retry if not. Because new nodes are always
appended to lists, once a node is first in a bin, it remains first until
deleted or the bin becomes invalidated (upon resizing).  However,
operations that only conditionally update may inspect nodes until the point
of update. This is a converse of sorts to the lazy locking technique
described by Herlihy &amp; Shavit.</p>

<p>The main disadvantage of per-bin locks is that other update operations on
other nodes in a bin list protected by the same lock can stall, for example
when user <tt>eql?</tt> or mapping functions take a long time.  However,
statistically, under random hash codes, this is not a common problem. 
Ideally, the frequency of nodes in bins follows a Poisson distribution (<a
href="http://en.wikipedia.org/wiki/Poisson_distribution">en.wikipedia.org/wiki/Poisson_distribution</a>)
with a parameter of about 0.5 on average, given the resizing threshold of
0.75, although with a large variance because of resizing granularity.
Ignoring variance, the expected occurrences of list size k are (exp(-0.5) *
pow(0.5, k) / factorial(k)). The first values are:</p>

<pre>0:    0.60653066
1:    0.30326533
2:    0.07581633
3:    0.01263606
4:    0.00157952
5:    0.00015795
6:    0.00001316
7:    0.00000094
8:    0.00000006
more: less than 1 in ten million</pre>

<p>Lock contention probability for two threads accessing distinct elements is
roughly 1 / (8 * elements) under random hashes.</p>

<p>The table is resized when occupancy exceeds a percentage threshold
(nominally, 0.75, but see below).  Only a single thread performs the resize
(using field <tt>size_control</tt>, to arrange exclusion), but the table
otherwise remains usable for reads and updates. Resizing proceeds by
transferring bins, one by one, from the table to the next table.  Because
we are using power-of-two expansion, the elements from each bin must either
stay at same index, or move with a power of two offset. We eliminate
unnecessary node creation by catching cases where old nodes can be reused
because their next fields won’t change.  On average, only about one-sixth
of them need cloning when a table doubles. The nodes they replace will be
garbage collectable as soon as they are no longer referenced by any reader
thread that may be in the midst of concurrently traversing table.  Upon
transfer, the old table bin contains only a special forwarding node (with
hash field <tt>MOVED</tt>) that contains the next table as its key. On
encountering a forwarding node, access and update operations restart, using
the new table.</p>

<p>Each bin transfer requires its bin lock. However, unlike other cases, a
transfer can skip a bin if it fails to acquire its lock, and revisit it
later. Method <tt>rebuild</tt> maintains a buffer of <a
href="AtomicReferenceCacheBackend.html#TRANSFER_BUFFER_SIZE">TRANSFER_BUFFER_SIZE</a>
bins that have been skipped because of failure to acquire a lock, and
blocks only if none are available (i.e., only very rarely). The transfer
operation must also ensure that all accessible bins in both the old and new
table are usable by any traversal. When there are no lock acquisition
failures, this is arranged simply by proceeding from the last bin
(+table.size - 1+) up towards the first.  Upon seeing a forwarding node,
traversals arrange to move to the new table without revisiting nodes.
However, when any node is skipped during a transfer, all earlier table bins
may have become visible, so are initialized with a reverse-forwarding node
back to the old table until the new ones are established. (This sometimes
requires transiently locking a forwarding node, which is possible under the
above encoding.) These more expensive mechanics trigger only when
necessary.</p>

<p>The traversal scheme also applies to partial traversals of ranges of bins
(via an alternate Traverser constructor) to support partitioned aggregate
operations.  Also, read-only operations give up if ever forwarded to a null
table, which provides support for shutdown-style clearing, which is also
not currently implemented.</p>

<p>Lazy table initialization minimizes footprint until first use.</p>

<p>The element count is maintained using a +ThreadSafe::Util::Adder+, which
avoids contention on updates but can encounter cache thrashing if read too
frequently during concurrent access. To avoid reading so often, resizing is
attempted either when a bin lock is contended, or upon adding to a bin
already holding two or more nodes (checked before adding in the
<tt>x_if_absent</tt> methods, after adding in others). Under uniform hash
distributions, the probability of this occurring at threshold is around
13%, meaning that only about 1 in 8 puts check threshold (and after
resizing, many fewer do so). But this approximation has high variance for
small table sizes, so we check on any collision for sizes &lt;= 64. The
bulk putAll operation further reduces contention by only committing count
updates upon these size checks.</p>

    </div><!-- description -->

    
    
    
    <div id="5Buntitled-5D" class="documentation-section">
      

      

      
      <!-- Constants -->
      <div id="constants-list" class="section">
        <h3 class="section-header">Constants</h3>
        <dl>
        
          <dt><a name="DEFAULT_CAPACITY">DEFAULT_CAPACITY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="HASH_BITS">HASH_BITS</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="LOCKED">LOCKED</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="MAX_CAPACITY">MAX_CAPACITY</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="MOVED">MOVED</a></dt>
          
          <dd class="description"><p>shorthands</p></dd>
          
        
          <dt><a name="NOW_RESIZING">NOW_RESIZING</a></dt>
          
          <dd class="description"></dd>
          
        
          <dt><a name="TRANSFER_BUFFER_SIZE">TRANSFER_BUFFER_SIZE</a></dt>
          
          <dd class="description"><p>The buffer size for skipped bins during transfers. The value is arbitrary
but should be large enough to avoid most locking stalls during resizes.</p></dd>
          
        
          <dt><a name="WAITING">WAITING</a></dt>
          
          <dd class="description"></dd>
          
        
        </dl>
      </div>
      

      

      <!-- Methods -->
      
      <div id="public-class-method-details" class="method-section section">
        <h3 class="section-header">Public Class Methods</h3>

      
        <div id="new-method" class="method-detail ">
          <a name="method-c-new"></a>

          
          <div class="method-heading">
            <span class="method-name">new</span><span
              class="method-args">(options = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="new-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 370</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">initialize</span>(<span class="ruby-identifier">options</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-keyword">super</span>()
  <span class="ruby-ivar">@counter</span> = <span class="ruby-constant">Util</span><span class="ruby-operator">::</span><span class="ruby-constant">Adder</span>.<span class="ruby-identifier">new</span>
  <span class="ruby-identifier">initial_capacity</span>  = <span class="ruby-identifier">options</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>[<span class="ruby-value">:initial_capacity</span>] <span class="ruby-operator">||</span> <span class="ruby-constant">DEFAULT_CAPACITY</span>
  <span class="ruby-keyword">self</span>.<span class="ruby-identifier">size_control</span> = (<span class="ruby-identifier">capacity</span> = <span class="ruby-identifier">table_size_for</span>(<span class="ruby-identifier">initial_capacity</span>)) <span class="ruby-operator">&gt;</span> <span class="ruby-constant">MAX_CAPACITY</span> <span class="ruby-operator">?</span> <span class="ruby-constant">MAX_CAPACITY</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">capacity</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- new-source -->
            
          </div>

          

          
        </div><!-- new-method -->

      
      </div><!-- public-class-method-details -->
    
      <div id="public-instance-method-details" class="method-section section">
        <h3 class="section-header">Public Instance Methods</h3>

      
        <div id="5B-5D-method" class="method-detail ">
          <a name="method-i-5B-5D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="5B-5D-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 395</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- 5B-5D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-method -->

      
        <div id="5B-5D-3D-method" class="method-detail ">
          <a name="method-i-5B-5D-3D"></a>

          
          <div class="method-heading">
            <span class="method-name">[]=</span><span
              class="method-args">(key, value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="5B-5D-3D-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 403</span>
<span class="ruby-keyword">def</span> <span class="ruby-operator">[]=</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">value</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- 5B-5D-3D-source -->
            
          </div>

          

          
        </div><!-- 5B-5D-3D-method -->

      
        <div id="clear-method" class="method-detail ">
          <a name="method-i-clear"></a>

          
          <div class="method-heading">
            <span class="method-name">clear</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            <p>Implementation for clear. Steps through each bin, removing all nodes.</p>
            

            
            <div class="method-source-code" id="clear-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 542</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">clear</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">deleted_count</span> = <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">current_table_size</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span>))
      <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span>      = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
      <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">decrement_size</span>(<span class="ruby-identifier">deleted_count</span>) <span class="ruby-comment"># opportunistically update count</span>
      <span class="ruby-identifier">deleted_count</span> = <span class="ruby-value">0</span>
      <span class="ruby-identifier">node</span>.<span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">try_lock_via_hash</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>) <span class="ruby-keyword">do</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-identifier">deleted_count</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span> <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> <span class="ruby-comment"># recheck under lock</span>
          <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> = <span class="ruby-keyword">nil</span>
        <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
        <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_set</span>(<span class="ruby-identifier">i</span>, <span class="ruby-keyword">nil</span>)
        <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">decrement_size</span>(<span class="ruby-identifier">deleted_count</span>)
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- clear-source -->
            
          </div>

          

          
        </div><!-- clear-method -->

      
        <div id="compute-method" class="method-detail ">
          <a name="method-i-compute"></a>

          
          <div class="method-heading">
            <span class="method-name">compute</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="compute-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 443</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">internal_compute</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">new_value</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- compute-source -->
            
          </div>

          

          
        </div><!-- compute-method -->

      
        <div id="compute_if_absent-method" class="method-detail ">
          <a name="method-i-compute_if_absent"></a>

          
          <div class="method-heading">
            <span class="method-name">compute_if_absent</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="compute_if_absent-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 408</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_if_absent</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">initialize_table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">hash_to_index</span>(<span class="ruby-identifier">hash</span>)))
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">new_value</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">try_to_cas_in_computed</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>) { <span class="ruby-keyword">yield</span> }
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
        <span class="ruby-identifier">increment_size</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">new_value</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">current_value</span> = <span class="ruby-identifier">find_value_in_node_list</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">node_hash</span> &amp; <span class="ruby-constant">HASH_BITS</span>))
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">current_value</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">value</span> = <span class="ruby-identifier">attempt_internal_compute_if_absent</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>) { <span class="ruby-keyword">yield</span> }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- compute_if_absent-source -->
            
          </div>

          

          
        </div><!-- compute_if_absent-method -->

      
        <div id="compute_if_present-method" class="method-detail ">
          <a name="method-i-compute_if_present"></a>

          
          <div class="method-heading">
            <span class="method-name">compute_if_present</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="compute_if_present-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 431</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">compute_if_present</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">nil</span>
  <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">new_value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">?</span> <span class="ruby-keyword">nil</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">new_value</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">new_value</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- compute_if_present-source -->
            
          </div>

          

          
        </div><!-- compute_if_present-method -->

      
        <div id="delete-method" class="method-detail ">
          <a name="method-i-delete"></a>

          
          <div class="method-heading">
            <span class="method-name">delete</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="delete-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 493</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-constant">NULL</span>)
<span class="ruby-keyword">end</span></pre>
            </div><!-- delete-source -->
            
          </div>

          

          
        </div><!-- delete-method -->

      
        <div id="delete_pair-method" class="method-detail ">
          <a name="method-i-delete_pair"></a>

          
          <div class="method-heading">
            <span class="method-name">delete_pair</span><span
              class="method-args">(key, value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="delete_pair-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 497</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">delete_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">result</span> = <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) { <span class="ruby-constant">NULL</span> }
  <span class="ruby-keyword">if</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">result</span>
    <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">result</span>
  <span class="ruby-keyword">else</span>
    <span class="ruby-keyword">false</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- delete_pair-source -->
            
          </div>

          

          
        </div><!-- delete_pair-method -->

      
        <div id="each_pair-method" class="method-detail ">
          <a name="method-i-each_pair"></a>

          
          <div class="method-heading">
            <span class="method-name">each_pair</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="each_pair-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 506</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">each_pair</span>
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">self</span> <span class="ruby-keyword">unless</span> <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">base_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
  <span class="ruby-identifier">i</span> = <span class="ruby-identifier">base_index</span> = <span class="ruby-value">0</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">base_index</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">base_size</span>
    <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span>)
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span> <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
        <span class="ruby-identifier">current_table</span>      = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
        <span class="ruby-identifier">current_table_size</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">size</span>
      <span class="ruby-keyword">else</span>
        <span class="ruby-keyword">begin</span>
          <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">value</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>) <span class="ruby-comment"># skip deleted or special nodes</span>
            <span class="ruby-keyword">yield</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>
          <span class="ruby-keyword">end</span>
        <span class="ruby-keyword">end</span> <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">end</span>

    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i_with_base</span> = <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">base_size</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">current_table_size</span>
      <span class="ruby-identifier">i</span> = <span class="ruby-identifier">i_with_base</span> <span class="ruby-comment"># visit upper slots if present</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">i</span> = <span class="ruby-identifier">base_index</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">self</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- each_pair-source -->
            
          </div>

          

          
        </div><!-- each_pair-method -->

      
        <div id="empty-3F-method" class="method-detail ">
          <a name="method-i-empty-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">empty?</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="empty-3F-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 537</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">empty?</span>
  <span class="ruby-identifier">size</span> <span class="ruby-operator">==</span> <span class="ruby-value">0</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- empty-3F-source -->
            
          </div>

          

          
        </div><!-- empty-3F-method -->

      
        <div id="get_and_set-method" class="method-detail ">
          <a name="method-i-get_and_set"></a>

          
          <div class="method-heading">
            <span class="method-name">get_and_set</span><span
              class="method-args">(key, value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_and_set-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 473</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>) <span class="ruby-comment"># internalPut in the original CHMV8</span>
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">initialize_table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-keyword">true</span>
    <span class="ruby-keyword">if</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get</span>(<span class="ruby-identifier">i</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">hash_to_index</span>(<span class="ruby-identifier">hash</span>)))
      <span class="ruby-keyword">if</span> <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">cas_new_node</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
        <span class="ruby-identifier">increment_size</span>
        <span class="ruby-keyword">break</span>
      <span class="ruby-keyword">end</span>
    <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
      <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
    <span class="ruby-keyword">elsif</span> <span class="ruby-constant">Node</span>.<span class="ruby-identifier">locked_hash?</span>(<span class="ruby-identifier">node_hash</span>)
      <span class="ruby-identifier">try_await_lock</span>(<span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>)
    <span class="ruby-keyword">else</span>
      <span class="ruby-identifier">succeeded</span>, <span class="ruby-identifier">old_value</span> = <span class="ruby-identifier">attempt_get_and_set</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">hash</span>, <span class="ruby-identifier">current_table</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">node_hash</span>)
      <span class="ruby-keyword">break</span> <span class="ruby-identifier">old_value</span> <span class="ruby-keyword">if</span> <span class="ruby-identifier">succeeded</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_and_set-source -->
            
          </div>

          

          
        </div><!-- get_and_set-method -->

      
        <div id="get_or_default-method" class="method-detail ">
          <a name="method-i-get_or_default"></a>

          
          <div class="method-heading">
            <span class="method-name">get_or_default</span><span
              class="method-args">(key, else_value = nil)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="get_or_default-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 377</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">else_value</span> = <span class="ruby-keyword">nil</span>)
  <span class="ruby-identifier">hash</span>          = <span class="ruby-identifier">key_hash</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">current_table</span> = <span class="ruby-identifier">table</span>
  <span class="ruby-keyword">while</span> <span class="ruby-identifier">current_table</span>
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">current_table</span>.<span class="ruby-identifier">volatile_get_by_hash</span>(<span class="ruby-identifier">hash</span>)
    <span class="ruby-identifier">current_table</span> =
      <span class="ruby-keyword">while</span> <span class="ruby-identifier">node</span>
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node_hash</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">hash</span>) <span class="ruby-operator">==</span> <span class="ruby-constant">MOVED</span>
          <span class="ruby-keyword">break</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key</span>
        <span class="ruby-keyword">elsif</span> (<span class="ruby-identifier">node_hash</span> &amp; <span class="ruby-constant">HASH_BITS</span>) <span class="ruby-operator">==</span> <span class="ruby-identifier">hash</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> (<span class="ruby-identifier">value</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>)
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">value</span>
        <span class="ruby-keyword">end</span>
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">next</span>
      <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
  <span class="ruby-identifier">else_value</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- get_or_default-source -->
            
          </div>

          

          
        </div><!-- get_or_default-method -->

      
        <div id="key-3F-method" class="method-detail ">
          <a name="method-i-key-3F"></a>

          
          <div class="method-heading">
            <span class="method-name">key?</span><span
              class="method-args">(key)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="key-3F-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 399</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">key?</span>(<span class="ruby-identifier">key</span>)
  <span class="ruby-identifier">get_or_default</span>(<span class="ruby-identifier">key</span>, <span class="ruby-constant">NULL</span>) <span class="ruby-operator">!=</span> <span class="ruby-constant">NULL</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- key-3F-source -->
            
          </div>

          

          
        </div><!-- key-3F-method -->

      
        <div id="merge_pair-method" class="method-detail ">
          <a name="method-i-merge_pair"></a>

          
          <div class="method-heading">
            <span class="method-name">merge_pair</span><span
              class="method-args">(key, value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="merge_pair-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 453</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">merge_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">value</span>)
  <span class="ruby-identifier">internal_compute</span>(<span class="ruby-identifier">key</span>) <span class="ruby-keyword">do</span> <span class="ruby-operator">|</span><span class="ruby-identifier">old_value</span><span class="ruby-operator">|</span>
    <span class="ruby-keyword">if</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">old_value</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">value</span> = <span class="ruby-keyword">yield</span>(<span class="ruby-identifier">old_value</span>)).<span class="ruby-identifier">nil?</span>
      <span class="ruby-identifier">value</span>
    <span class="ruby-keyword">else</span>
      <span class="ruby-constant">NULL</span>
    <span class="ruby-keyword">end</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- merge_pair-source -->
            
          </div>

          

          
        </div><!-- merge_pair-method -->

      
        <div id="replace_if_exists-method" class="method-detail ">
          <a name="method-i-replace_if_exists"></a>

          
          <div class="method-heading">
            <span class="method-name">replace_if_exists</span><span
              class="method-args">(key, new_value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="replace_if_exists-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 467</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">replace_if_exists</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">new_value</span>)
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">result</span> = <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>) { <span class="ruby-identifier">new_value</span> }) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">result</span>
    <span class="ruby-identifier">result</span>
  <span class="ruby-keyword">end</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- replace_if_exists-source -->
            
          </div>

          

          
        </div><!-- replace_if_exists-method -->

      
        <div id="replace_pair-method" class="method-detail ">
          <a name="method-i-replace_pair"></a>

          
          <div class="method-heading">
            <span class="method-name">replace_pair</span><span
              class="method-args">(key, old_value, new_value)</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="replace_pair-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 463</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">replace_pair</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>, <span class="ruby-identifier">new_value</span>)
  <span class="ruby-constant">NULL</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">internal_replace</span>(<span class="ruby-identifier">key</span>, <span class="ruby-identifier">old_value</span>) { <span class="ruby-identifier">new_value</span> }
<span class="ruby-keyword">end</span></pre>
            </div><!-- replace_pair-source -->
            
          </div>

          

          
        </div><!-- replace_pair-method -->

      
        <div id="size-method" class="method-detail ">
          <a name="method-i-size"></a>

          
          <div class="method-heading">
            <span class="method-name">size</span><span
              class="method-args">()</span>
            <span class="method-click-advice">click to toggle source</span>
          </div>
          

          <div class="method-description">
            
            
            

            
            <div class="method-source-code" id="size-source">
<pre>
<span class="ruby-comment"># File lib/thread_safe/atomic_reference_cache_backend.rb, line 533</span>
<span class="ruby-keyword">def</span> <span class="ruby-identifier">size</span>
  (<span class="ruby-identifier">sum</span> = <span class="ruby-ivar">@counter</span>.<span class="ruby-identifier">sum</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sum</span> <span class="ruby-comment"># ignore transient negative values</span>
<span class="ruby-keyword">end</span></pre>
            </div><!-- size-source -->
            
          </div>

          

          
        </div><!-- size-method -->

      
      </div><!-- public-instance-method-details -->
    
    </div><!-- 5Buntitled-5D -->
  

  </div><!-- documentation -->

  <div id="validator-badges">
    <p><small><a href="http://validator.w3.org/check/referer">[Validate]</a></small></p>
    <p><small>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish
      Rdoc Generator</a> 2</small>.</p>
  </div>

</body>
</html>

